import pandas as pd
from os import listdir, mkdir, makedirs
from os.path import isdir, join
from shutil import rmtree, move
import numpy as np

def loadIntoArray(fname:      str,
                  headerline: bool = True,
                  verbose:    bool = True):
    """
    Loads the contents of the file into a numpy.ndarray. Returns the array and header line, if present.
    """
    if verbose:
        print('Loading file ' + fname + ' ...')

    if headerline:
        df = pd.read_csv(filepath_or_buffer = fname,
                         dtype = np.float64,
                         delim_whitespace = True)
        return df.values, df.columns
    else:
        df = pd.read_csv(filepath_or_buffer = fname,
                         header = None,
                         dtype = np.float64,
                         delim_whitespace = True)
        return df.values, []

def loadmat(fname:     str,
            mdict:     dict = None,
            appendmat: bool = True,
            **kwargs):
    """
    Wrapper function for scipy.io.loadmat which uses numpy.squeeze to remove singular dimensions from arrays
    in the dict returned.

    API doc: http://docs.scipy.org/doc/scipy-0.16.0/reference/generated/scipy.io.loadmat.html
    """

    mat = loadmat(fname, mdict, appendmat, **kwargs)

    for k in mat.keys():
        mat[k] = np.squeeze(mat[k])

    return mat

def writeArrayToFile(fname:   str,                 # name & location to save
                     data:    '2D numpy.ndarray',  # matrix of data to write
                     header:  list = (),           # header line
                     verbose: bool = True):
    """
    Writes the contents of the array into the file.
    """

    if verbose:
        print('Writing file ' + fname + ' ...')

    df = pd.DataFrame(data)
    df.to_csv(path_or_buf  = fname,
              sep          = ' ',
              float_format = '%.16e',
              header       = header,
              index        = False)

def makeCleanPath(path: str):
    """
    Creates a clean path at the location specified.  Makes sure the location (1) exists, and
    (2) doesn't have old files in it.  By default, if the directory exists and is not empty,
    creates the sub directory named by the variable PREVDIR in which to store the prior contents.
    It also creates a file WARNFIL with a warning about the fragility of the directory.

    :param   path: the path to be created/emptied
    :return  None

    NOTES:
    ------
    * Useful for quickly making a directory to dump plots, datafiles, etc.
    * PREV directory is for quick oh shit prevention; should not be used in lieu of version control
    """

    PREVDIR = '_@prev'
    WARNFIL = '_@autogen_warning.txt'
    MSG = '''
          WARNING:\n
          This directory and contents were generated by a script which routinely deletes the \n
          contents herein.  Unless version controlled, any data in this directory can be \n
          destroyed forever if the script is re-run.
          '''

    prevdir = join(path, PREVDIR)

    if not isdir(path):
        makedirs(path)
    else:
        ls = set(listdir(path)) # get list of files/dirs
        if isdir(prevdir):
            ls.discard(PREVDIR) # don't include prevdir in move
            rmtree(prevdir)
        mkdir(prevdir)          # make a new empty prevdir
        for name in ls:         # move the old files into prevdir
            move(join(path, name), join(prevdir, name))

    with open(join(path, WARNFIL), 'w') as f:
        f.write(MSG)
